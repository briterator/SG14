<!DOCTYPE html><html><head><meta charset="utf-8"><title>P0041R1</title><style></style></head><body id="preview">
<p>LEWG, SG14: P0041R1<br>
17-10-2015<br>
Brent Friedman<br>
<a href="mailto:fourthgeek@gmail.com">fourthgeek@gmail.com</a></p>
<h1><a id="Unstable_remove_algorithms_5"></a>Unstable remove algorithms</h1>
<h2><a id="I_Summary_7"></a>I. Summary</h2>
<p>This proposal covers new algorithms for removing elements from a range without the stability guarantees of existing algorithms.</p>
<h2><a id="II_Motivation_11"></a>II. Motivation</h2>
<p>The stability requirements of existing remove algorithms incur costs to maintain element order. The proposed algorithms can perform far fewer moves in many circumstances, doing so at the cost of losing element order.</p>
<p>The following URL demonstrates generated assembly for implementations of <code>remove_if</code>, <code>partition</code>, and <code>unstable_remove_if</code>. These implementations closely match current implementations in the Dinkumware standard library implementation.<br>
<a href="https://goo.gl/xfCxzL">https://goo.gl/xfCxzL</a></p>
<p>It is observed that <code>unstable_remove_if</code> generates less code than <code>remove_if</code> and <code>partition</code>. <code>remove_if</code> generates additional instructions due to being implemented as a concatenation of two loops. <code>partition</code> generates additional instructions due to the overhead of swap vs. move. <code>unstable_remove_if</code> combines the best performance characteristics of these two algorithms.</p>
<p>Performance tests have been reported in the SG14 reflector:<br>
<a href="https://groups.google.com/a/isocpp.org/forum/#!topic/sg14/0mwiBYyzz-A">https://groups.google.com/a/isocpp.org/forum/#!topic/sg14/0mwiBYyzz-A</a></p>
<p>It is observed that <code>unstable_remove_if</code> can outperform both <code>remove_if</code> and <code>partition</code> by a measurable degree.</p>
<p>These examples suggest that unstable_remove algorithms can be both smaller and faster than existing solutions.</p>
<h2><a id="III_Additional_work_27"></a>III. Additional work</h2>
<p>Algorithmic changes proposed in the “range” proposals should be applied to these algorithms if both are accepted.</p>
<p>The value of unstable_remove can be applied to containers directly, implying <code>unstable_erase*</code> algorithms or member functions. The following pseudocode signatures are informally provided here for reference and discussion but are not proposed in this paper.</p>
<pre><code>
It container::unstable_erase(It begin, It end);
It unstable_erase(Cont&amp; C, It at);
It unstable_erase(Cont&amp; C, It begin, It end);
It unstable_erase_if(Cont&amp; C, Pred p); //unstable_remove_if + erase
It unstable_erase(Cont&amp; C, const T&amp; value); //unstable_remove + erase
</code></pre>
<h2><a id="IV_Discussion_42"></a>IV. Discussion</h2>
<p>Some skepticism is levied against the utility of creating unstable variants for all erase and remove features. The cost and value of each variant may be difficult to evaluate individually, which is why this proposal covers only the most fundamental functionality of <code>unstable_remove</code> and <code>unstable_remove_if</code>. This author does believe that all removal and erasure features with stability guarantees should have variants without those stability guarantees when benefits can be demonstrated.</p>
<p>Some see unstable container erasure as even more important than <code>unstable_remove</code>. It is in the author’s opinion that <code>unstable_remove</code> algorithms remain independently useful in many contexts (such as fixed sized containers) and constitute more fundamental functionality than erasure.</p>
<p>Containers that do not support bidirectional iterators would likely not benefit from unstable removal or erasure.</p>
<p>It is noted that for <code>vector&lt;int&gt; x</code>, and the following code samples,</p>
<pre><code>x.unstable_erase( unstable_remove( x.begin(), x.end(), 0), x.end()); //A.
x.erase( unstable_remove(x.begin(), x.end(), 0), x.end()); //B.
</code></pre>
<p>A provides no efficiency benefits over B. unstable_erase provides benefits only when the range to be removed occurs within the middle of the container. Providing <code>erase</code>, <code>unstable_erase</code>, <code>remove</code>, and <code>unstable_remove</code> features could lead to some confusion among users as to the compatibility and best practices for using them together.</p>
<h2><a id="V_Proposed_Wording_57"></a>V. Proposed Wording</h2>
<p>In [alg.remove]  First section:</p>
<pre><code>template&lt;class ForwardIterator, class T&gt; ForwardIterator unstable_remove(ForwardIterator first, ForwardIterator last, const T&amp; value);   
template&lt;class ForwardIterator, class Predicate&gt; ForwardIterator unstable_remove_if(ForwardIterator first, ForwardIterator last,Predicate pred);
</code></pre>
<p>Remarks (<code>remove, remove_if</code>): Stable</p>
<p>Second section:</p>
<pre><code>template&lt;class InputIterator, class OutputIterator, class T&gt; OutputIterator unstable_remove_copy(InputIterator first, InputIterator last, OutputIterator result, const T&amp; value);

template&lt;class InputIterator, class OutputIterator, class Predicate&gt; OutputIterator unstable_remove_copy_if(InputIterator first, InputIterator last, OutputIterator result, Predicate pred);   
</code></pre>
<p>Remarks (<code>remove_copy, remove_copy_if</code>): Stable</p>

</body></html>